import org.gradle.api.artifacts.*

apply plugin: 'base' // To add "clean" task to the root project.

subprojects {
    apply from: rootProject.file('common.gradle')
}

def moduleDir = new File("${project('FlowPro').projectDir}/modules")
if (!moduleDir.exists()) {
    moduleDir.mkdirs()
}

def File modelProjectDir = new File("${rootDir}/ModuleProjects")


subprojects {
    def projectName = "$project.name"
    println projectName
    if (projectName != 'FlowPro' && projectName != 'FlowProAPI') {
//project(':Aerodynamics') {
    dependencies {
        implementation project(':FlowProAPI')
    }
        
    task copyJar(type: Copy) {
        def File projectDir = new File("${projectDir}")
        def relPath = modelProjectDir.toPath().relativize(projectDir.getParentFile().toPath())
        def modulJarDir = new File(moduleDir.toPath().toString() + '/' + relPath)
        if (!modulJarDir.exists()) {
            modulJarDir.mkdirs()
        }
        
        from jar
        into modulJarDir
        rename { String fileName ->
            fileName = "${project.name}.jar"
        }
    }
    jar.finalizedBy copyJar
    }
}

project(':FlowPro') {
    dependencies {
        implementation project(':FlowProAPI')
    }
}

task mergedJavadoc(type: Javadoc, description: 'Creates Javadoc from all the projects.') {
    title = 'All modules'
    destinationDir = new File(project.buildDir, 'merged-javadoc')

    // Note: The closures below are executed lazily.
    source {
        subprojects*.sourceSets*.main*.allSource
    }
    classpath.from {
        subprojects*.configurations*.compile*.copyRecursive({ !(it instanceof ProjectDependency); })*.resolve()
    }
}

// buildScan { licenseAgreementUrl = 'https://gradle.com/terms-of-service'; licenseAgree = 'yes' }
